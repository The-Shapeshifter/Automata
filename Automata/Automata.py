from queue import Queue
from SubPub import MosquittoSub
import signal
from os import system, name


def handler(signum, frame):
    res = input("Ctrl-c was pressed. Do you really want to exit? y/n ")
    if res == 'y':
        print("---------------------------------------------------\n"
              "Closing...")
        sub.halt()
        exit(0)


signal.signal(signal.SIGINT, handler)

if __name__ == '__main__':

    # Let's start with a clean screen!
    # for windows
    if name == 'nt':
        system('cls')
    # for mac and linux(here, os.name is 'posix')
    else:
        system('clear')

    # queue initializing: the queue will be shared between this main process and the Mosquitto thread generated by the
    # subscriber class

    queue = Queue()

    # This is a Singleton
    sub = MosquittoSub.MosquittoSub("tester", queue)

    # are we connected successfully? the first thing that the program wants to find is a "True"
    # value in the pipe sent by the subscriber when everything is started correctly
    if queue.get():
        print("Connected!\n"
              "Log start:\n"
              "---------------------------------------------------\n")
    else:
        print("Error while connecting to broker, exiting...")
        exit(1)

    # Simple loop: it checks if the queue is empty, if it is not it lock the thread and retrieve the data;
    # if message is a bool, it means that the subscriber has encountered an error caused by the timeout of the
    # connection with the broker: the program exits as gracefully as possible
    while True:
        if not queue.empty():
            message = queue.get()
            if type(message) is bool and message is False:
                print("Error while retrieving data:\n\t The broker has encountered an error")
                exit(1)

            print(message[0] + " --> " + message[1])
